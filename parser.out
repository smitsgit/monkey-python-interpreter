Grammar:

Rule 0     S' -> statements
Rule 1     statements -> blk_statements
Rule 2     statements -> statement
Rule 3     statements -> statements statement
Rule 4     blk_statements -> LBRACE statements RBRACE
Rule 5     statement -> FUNC LPAREN params RPAREN statements
Rule 6     statement -> if_statement
Rule 7     statement -> return_statement
Rule 8     statement -> let_statement
Rule 9     let_statement -> LET ID ASSIGN expr SEMICOLON
Rule 10    return_statement -> RETURN expr SEMICOLON
Rule 11    if_statement -> IF expr statements ELSE statements
Rule 12    params -> param
Rule 13    params -> params COMMA param
Rule 14    param -> ID
Rule 15    expr -> ID
Rule 16    expr -> NUMBER
Rule 17    expr -> FALSE
Rule 18    expr -> TRUE
Rule 19    expr -> NOT expr  [precedence=right, level=5]
Rule 20    expr -> MINUS expr  [precedence=right, level=5]
Rule 21    expr -> LPAREN expr RPAREN
Rule 22    expr -> expr NE expr  [precedence=left, level=1]
Rule 23    expr -> expr EQ expr  [precedence=left, level=1]
Rule 24    expr -> expr GT expr  [precedence=left, level=2]
Rule 25    expr -> expr LT expr  [precedence=left, level=2]
Rule 26    expr -> expr DIVIDE expr  [precedence=left, level=4]
Rule 27    expr -> expr TIMES expr  [precedence=left, level=4]
Rule 28    expr -> expr MINUS expr  [precedence=left, level=3]
Rule 29    expr -> expr PLUS expr  [precedence=left, level=3]

Unused terminals:

    GE
    LE
    PRINT
    WHILE

Terminals, with rules where they appear:

ASSIGN               : 9
COMMA                : 13
DIVIDE               : 26
ELSE                 : 11
EQ                   : 23
FALSE                : 17
FUNC                 : 5
GE                   : 
GT                   : 24
ID                   : 9 14 15
IF                   : 11
LBRACE               : 4
LE                   : 
LET                  : 9
LPAREN               : 5 21
LT                   : 25
MINUS                : 20 28
NE                   : 22
NOT                  : 19
NUMBER               : 16
PLUS                 : 29
PRINT                : 
RBRACE               : 4
RETURN               : 10
RPAREN               : 5 21
SEMICOLON            : 9 10
TIMES                : 27
TRUE                 : 18
WHILE                : 
error                : 

Nonterminals, with rules where they appear:

blk_statements       : 1
expr                 : 9 10 11 19 20 21 22 22 23 23 24 24 25 25 26 26 27 27 28 28 29 29
if_statement         : 6
let_statement        : 8
param                : 12 13
params               : 5 13
return_statement     : 7
statement            : 2 3
statements           : 3 4 5 11 11 0


state 0

    (0) S' -> . statements
    (1) statements -> . blk_statements
    (2) statements -> . statement
    (3) statements -> . statements statement
    (4) blk_statements -> . LBRACE statements RBRACE
    (5) statement -> . FUNC LPAREN params RPAREN statements
    (6) statement -> . if_statement
    (7) statement -> . return_statement
    (8) statement -> . let_statement
    (11) if_statement -> . IF expr statements ELSE statements
    (10) return_statement -> . RETURN expr SEMICOLON
    (9) let_statement -> . LET ID ASSIGN expr SEMICOLON
    LBRACE          shift and go to state 4
    FUNC            shift and go to state 5
    IF              shift and go to state 9
    RETURN          shift and go to state 10
    LET             shift and go to state 11

    statements                     shift and go to state 1
    blk_statements                 shift and go to state 2
    statement                      shift and go to state 3
    if_statement                   shift and go to state 6
    return_statement               shift and go to state 7
    let_statement                  shift and go to state 8

state 1

    (0) S' -> statements .
    (3) statements -> statements . statement
    (5) statement -> . FUNC LPAREN params RPAREN statements
    (6) statement -> . if_statement
    (7) statement -> . return_statement
    (8) statement -> . let_statement
    (11) if_statement -> . IF expr statements ELSE statements
    (10) return_statement -> . RETURN expr SEMICOLON
    (9) let_statement -> . LET ID ASSIGN expr SEMICOLON
    FUNC            shift and go to state 5
    IF              shift and go to state 9
    RETURN          shift and go to state 10
    LET             shift and go to state 11

    statement                      shift and go to state 12
    if_statement                   shift and go to state 6
    return_statement               shift and go to state 7
    let_statement                  shift and go to state 8

state 2

    (1) statements -> blk_statements .
    FUNC            reduce using rule 1 (statements -> blk_statements .)
    IF              reduce using rule 1 (statements -> blk_statements .)
    RETURN          reduce using rule 1 (statements -> blk_statements .)
    LET             reduce using rule 1 (statements -> blk_statements .)
    $end            reduce using rule 1 (statements -> blk_statements .)
    RBRACE          reduce using rule 1 (statements -> blk_statements .)
    ELSE            reduce using rule 1 (statements -> blk_statements .)


state 3

    (2) statements -> statement .
    FUNC            reduce using rule 2 (statements -> statement .)
    IF              reduce using rule 2 (statements -> statement .)
    RETURN          reduce using rule 2 (statements -> statement .)
    LET             reduce using rule 2 (statements -> statement .)
    $end            reduce using rule 2 (statements -> statement .)
    RBRACE          reduce using rule 2 (statements -> statement .)
    ELSE            reduce using rule 2 (statements -> statement .)


state 4

    (4) blk_statements -> LBRACE . statements RBRACE
    (1) statements -> . blk_statements
    (2) statements -> . statement
    (3) statements -> . statements statement
    (4) blk_statements -> . LBRACE statements RBRACE
    (5) statement -> . FUNC LPAREN params RPAREN statements
    (6) statement -> . if_statement
    (7) statement -> . return_statement
    (8) statement -> . let_statement
    (11) if_statement -> . IF expr statements ELSE statements
    (10) return_statement -> . RETURN expr SEMICOLON
    (9) let_statement -> . LET ID ASSIGN expr SEMICOLON
    LBRACE          shift and go to state 4
    FUNC            shift and go to state 5
    IF              shift and go to state 9
    RETURN          shift and go to state 10
    LET             shift and go to state 11

    statements                     shift and go to state 13
    blk_statements                 shift and go to state 2
    statement                      shift and go to state 3
    if_statement                   shift and go to state 6
    return_statement               shift and go to state 7
    let_statement                  shift and go to state 8

state 5

    (5) statement -> FUNC . LPAREN params RPAREN statements
    LPAREN          shift and go to state 14


state 6

    (6) statement -> if_statement .
    FUNC            reduce using rule 6 (statement -> if_statement .)
    IF              reduce using rule 6 (statement -> if_statement .)
    RETURN          reduce using rule 6 (statement -> if_statement .)
    LET             reduce using rule 6 (statement -> if_statement .)
    $end            reduce using rule 6 (statement -> if_statement .)
    RBRACE          reduce using rule 6 (statement -> if_statement .)
    ELSE            reduce using rule 6 (statement -> if_statement .)


state 7

    (7) statement -> return_statement .
    FUNC            reduce using rule 7 (statement -> return_statement .)
    IF              reduce using rule 7 (statement -> return_statement .)
    RETURN          reduce using rule 7 (statement -> return_statement .)
    LET             reduce using rule 7 (statement -> return_statement .)
    $end            reduce using rule 7 (statement -> return_statement .)
    RBRACE          reduce using rule 7 (statement -> return_statement .)
    ELSE            reduce using rule 7 (statement -> return_statement .)


state 8

    (8) statement -> let_statement .
    FUNC            reduce using rule 8 (statement -> let_statement .)
    IF              reduce using rule 8 (statement -> let_statement .)
    RETURN          reduce using rule 8 (statement -> let_statement .)
    LET             reduce using rule 8 (statement -> let_statement .)
    $end            reduce using rule 8 (statement -> let_statement .)
    RBRACE          reduce using rule 8 (statement -> let_statement .)
    ELSE            reduce using rule 8 (statement -> let_statement .)


state 9

    (11) if_statement -> IF . expr statements ELSE statements
    (15) expr -> . ID
    (16) expr -> . NUMBER
    (17) expr -> . FALSE
    (18) expr -> . TRUE
    (19) expr -> . NOT expr
    (20) expr -> . MINUS expr
    (21) expr -> . LPAREN expr RPAREN
    (22) expr -> . expr NE expr
    (23) expr -> . expr EQ expr
    (24) expr -> . expr GT expr
    (25) expr -> . expr LT expr
    (26) expr -> . expr DIVIDE expr
    (27) expr -> . expr TIMES expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr PLUS expr
    ID              shift and go to state 16
    NUMBER          shift and go to state 17
    FALSE           shift and go to state 18
    TRUE            shift and go to state 19
    NOT             shift and go to state 20
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 22

    expr                           shift and go to state 15

state 10

    (10) return_statement -> RETURN . expr SEMICOLON
    (15) expr -> . ID
    (16) expr -> . NUMBER
    (17) expr -> . FALSE
    (18) expr -> . TRUE
    (19) expr -> . NOT expr
    (20) expr -> . MINUS expr
    (21) expr -> . LPAREN expr RPAREN
    (22) expr -> . expr NE expr
    (23) expr -> . expr EQ expr
    (24) expr -> . expr GT expr
    (25) expr -> . expr LT expr
    (26) expr -> . expr DIVIDE expr
    (27) expr -> . expr TIMES expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr PLUS expr
    ID              shift and go to state 16
    NUMBER          shift and go to state 17
    FALSE           shift and go to state 18
    TRUE            shift and go to state 19
    NOT             shift and go to state 20
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 22

    expr                           shift and go to state 23

state 11

    (9) let_statement -> LET . ID ASSIGN expr SEMICOLON
    ID              shift and go to state 24


state 12

    (3) statements -> statements statement .
    FUNC            reduce using rule 3 (statements -> statements statement .)
    IF              reduce using rule 3 (statements -> statements statement .)
    RETURN          reduce using rule 3 (statements -> statements statement .)
    LET             reduce using rule 3 (statements -> statements statement .)
    $end            reduce using rule 3 (statements -> statements statement .)
    RBRACE          reduce using rule 3 (statements -> statements statement .)
    ELSE            reduce using rule 3 (statements -> statements statement .)


state 13

    (4) blk_statements -> LBRACE statements . RBRACE
    (3) statements -> statements . statement
    (5) statement -> . FUNC LPAREN params RPAREN statements
    (6) statement -> . if_statement
    (7) statement -> . return_statement
    (8) statement -> . let_statement
    (11) if_statement -> . IF expr statements ELSE statements
    (10) return_statement -> . RETURN expr SEMICOLON
    (9) let_statement -> . LET ID ASSIGN expr SEMICOLON
    RBRACE          shift and go to state 25
    FUNC            shift and go to state 5
    IF              shift and go to state 9
    RETURN          shift and go to state 10
    LET             shift and go to state 11

    statement                      shift and go to state 12
    if_statement                   shift and go to state 6
    return_statement               shift and go to state 7
    let_statement                  shift and go to state 8

state 14

    (5) statement -> FUNC LPAREN . params RPAREN statements
    (12) params -> . param
    (13) params -> . params COMMA param
    (14) param -> . ID
    ID              shift and go to state 28

    params                         shift and go to state 26
    param                          shift and go to state 27

state 15

    (11) if_statement -> IF expr . statements ELSE statements
    (22) expr -> expr . NE expr
    (23) expr -> expr . EQ expr
    (24) expr -> expr . GT expr
    (25) expr -> expr . LT expr
    (26) expr -> expr . DIVIDE expr
    (27) expr -> expr . TIMES expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . PLUS expr
    (1) statements -> . blk_statements
    (2) statements -> . statement
    (3) statements -> . statements statement
    (4) blk_statements -> . LBRACE statements RBRACE
    (5) statement -> . FUNC LPAREN params RPAREN statements
    (6) statement -> . if_statement
    (7) statement -> . return_statement
    (8) statement -> . let_statement
    (11) if_statement -> . IF expr statements ELSE statements
    (10) return_statement -> . RETURN expr SEMICOLON
    (9) let_statement -> . LET ID ASSIGN expr SEMICOLON
    NE              shift and go to state 30
    EQ              shift and go to state 31
    GT              shift and go to state 32
    LT              shift and go to state 33
    DIVIDE          shift and go to state 34
    TIMES           shift and go to state 35
    MINUS           shift and go to state 36
    PLUS            shift and go to state 37
    LBRACE          shift and go to state 4
    FUNC            shift and go to state 5
    IF              shift and go to state 9
    RETURN          shift and go to state 10
    LET             shift and go to state 11

    statements                     shift and go to state 29
    blk_statements                 shift and go to state 2
    statement                      shift and go to state 3
    if_statement                   shift and go to state 6
    return_statement               shift and go to state 7
    let_statement                  shift and go to state 8

state 16

    (15) expr -> ID .
    NE              reduce using rule 15 (expr -> ID .)
    EQ              reduce using rule 15 (expr -> ID .)
    GT              reduce using rule 15 (expr -> ID .)
    LT              reduce using rule 15 (expr -> ID .)
    DIVIDE          reduce using rule 15 (expr -> ID .)
    TIMES           reduce using rule 15 (expr -> ID .)
    MINUS           reduce using rule 15 (expr -> ID .)
    PLUS            reduce using rule 15 (expr -> ID .)
    LBRACE          reduce using rule 15 (expr -> ID .)
    FUNC            reduce using rule 15 (expr -> ID .)
    IF              reduce using rule 15 (expr -> ID .)
    RETURN          reduce using rule 15 (expr -> ID .)
    LET             reduce using rule 15 (expr -> ID .)
    SEMICOLON       reduce using rule 15 (expr -> ID .)
    RPAREN          reduce using rule 15 (expr -> ID .)


state 17

    (16) expr -> NUMBER .
    NE              reduce using rule 16 (expr -> NUMBER .)
    EQ              reduce using rule 16 (expr -> NUMBER .)
    GT              reduce using rule 16 (expr -> NUMBER .)
    LT              reduce using rule 16 (expr -> NUMBER .)
    DIVIDE          reduce using rule 16 (expr -> NUMBER .)
    TIMES           reduce using rule 16 (expr -> NUMBER .)
    MINUS           reduce using rule 16 (expr -> NUMBER .)
    PLUS            reduce using rule 16 (expr -> NUMBER .)
    LBRACE          reduce using rule 16 (expr -> NUMBER .)
    FUNC            reduce using rule 16 (expr -> NUMBER .)
    IF              reduce using rule 16 (expr -> NUMBER .)
    RETURN          reduce using rule 16 (expr -> NUMBER .)
    LET             reduce using rule 16 (expr -> NUMBER .)
    SEMICOLON       reduce using rule 16 (expr -> NUMBER .)
    RPAREN          reduce using rule 16 (expr -> NUMBER .)


state 18

    (17) expr -> FALSE .
    NE              reduce using rule 17 (expr -> FALSE .)
    EQ              reduce using rule 17 (expr -> FALSE .)
    GT              reduce using rule 17 (expr -> FALSE .)
    LT              reduce using rule 17 (expr -> FALSE .)
    DIVIDE          reduce using rule 17 (expr -> FALSE .)
    TIMES           reduce using rule 17 (expr -> FALSE .)
    MINUS           reduce using rule 17 (expr -> FALSE .)
    PLUS            reduce using rule 17 (expr -> FALSE .)
    LBRACE          reduce using rule 17 (expr -> FALSE .)
    FUNC            reduce using rule 17 (expr -> FALSE .)
    IF              reduce using rule 17 (expr -> FALSE .)
    RETURN          reduce using rule 17 (expr -> FALSE .)
    LET             reduce using rule 17 (expr -> FALSE .)
    SEMICOLON       reduce using rule 17 (expr -> FALSE .)
    RPAREN          reduce using rule 17 (expr -> FALSE .)


state 19

    (18) expr -> TRUE .
    NE              reduce using rule 18 (expr -> TRUE .)
    EQ              reduce using rule 18 (expr -> TRUE .)
    GT              reduce using rule 18 (expr -> TRUE .)
    LT              reduce using rule 18 (expr -> TRUE .)
    DIVIDE          reduce using rule 18 (expr -> TRUE .)
    TIMES           reduce using rule 18 (expr -> TRUE .)
    MINUS           reduce using rule 18 (expr -> TRUE .)
    PLUS            reduce using rule 18 (expr -> TRUE .)
    LBRACE          reduce using rule 18 (expr -> TRUE .)
    FUNC            reduce using rule 18 (expr -> TRUE .)
    IF              reduce using rule 18 (expr -> TRUE .)
    RETURN          reduce using rule 18 (expr -> TRUE .)
    LET             reduce using rule 18 (expr -> TRUE .)
    SEMICOLON       reduce using rule 18 (expr -> TRUE .)
    RPAREN          reduce using rule 18 (expr -> TRUE .)


state 20

    (19) expr -> NOT . expr
    (15) expr -> . ID
    (16) expr -> . NUMBER
    (17) expr -> . FALSE
    (18) expr -> . TRUE
    (19) expr -> . NOT expr
    (20) expr -> . MINUS expr
    (21) expr -> . LPAREN expr RPAREN
    (22) expr -> . expr NE expr
    (23) expr -> . expr EQ expr
    (24) expr -> . expr GT expr
    (25) expr -> . expr LT expr
    (26) expr -> . expr DIVIDE expr
    (27) expr -> . expr TIMES expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr PLUS expr
    ID              shift and go to state 16
    NUMBER          shift and go to state 17
    FALSE           shift and go to state 18
    TRUE            shift and go to state 19
    NOT             shift and go to state 20
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 22

    expr                           shift and go to state 38

state 21

    (20) expr -> MINUS . expr
    (15) expr -> . ID
    (16) expr -> . NUMBER
    (17) expr -> . FALSE
    (18) expr -> . TRUE
    (19) expr -> . NOT expr
    (20) expr -> . MINUS expr
    (21) expr -> . LPAREN expr RPAREN
    (22) expr -> . expr NE expr
    (23) expr -> . expr EQ expr
    (24) expr -> . expr GT expr
    (25) expr -> . expr LT expr
    (26) expr -> . expr DIVIDE expr
    (27) expr -> . expr TIMES expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr PLUS expr
    ID              shift and go to state 16
    NUMBER          shift and go to state 17
    FALSE           shift and go to state 18
    TRUE            shift and go to state 19
    NOT             shift and go to state 20
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 22

    expr                           shift and go to state 39

state 22

    (21) expr -> LPAREN . expr RPAREN
    (15) expr -> . ID
    (16) expr -> . NUMBER
    (17) expr -> . FALSE
    (18) expr -> . TRUE
    (19) expr -> . NOT expr
    (20) expr -> . MINUS expr
    (21) expr -> . LPAREN expr RPAREN
    (22) expr -> . expr NE expr
    (23) expr -> . expr EQ expr
    (24) expr -> . expr GT expr
    (25) expr -> . expr LT expr
    (26) expr -> . expr DIVIDE expr
    (27) expr -> . expr TIMES expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr PLUS expr
    ID              shift and go to state 16
    NUMBER          shift and go to state 17
    FALSE           shift and go to state 18
    TRUE            shift and go to state 19
    NOT             shift and go to state 20
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 22

    expr                           shift and go to state 40

state 23

    (10) return_statement -> RETURN expr . SEMICOLON
    (22) expr -> expr . NE expr
    (23) expr -> expr . EQ expr
    (24) expr -> expr . GT expr
    (25) expr -> expr . LT expr
    (26) expr -> expr . DIVIDE expr
    (27) expr -> expr . TIMES expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . PLUS expr
    SEMICOLON       shift and go to state 41
    NE              shift and go to state 30
    EQ              shift and go to state 31
    GT              shift and go to state 32
    LT              shift and go to state 33
    DIVIDE          shift and go to state 34
    TIMES           shift and go to state 35
    MINUS           shift and go to state 36
    PLUS            shift and go to state 37


state 24

    (9) let_statement -> LET ID . ASSIGN expr SEMICOLON
    ASSIGN          shift and go to state 42


state 25

    (4) blk_statements -> LBRACE statements RBRACE .
    FUNC            reduce using rule 4 (blk_statements -> LBRACE statements RBRACE .)
    IF              reduce using rule 4 (blk_statements -> LBRACE statements RBRACE .)
    RETURN          reduce using rule 4 (blk_statements -> LBRACE statements RBRACE .)
    LET             reduce using rule 4 (blk_statements -> LBRACE statements RBRACE .)
    $end            reduce using rule 4 (blk_statements -> LBRACE statements RBRACE .)
    RBRACE          reduce using rule 4 (blk_statements -> LBRACE statements RBRACE .)
    ELSE            reduce using rule 4 (blk_statements -> LBRACE statements RBRACE .)


state 26

    (5) statement -> FUNC LPAREN params . RPAREN statements
    (13) params -> params . COMMA param
    RPAREN          shift and go to state 43
    COMMA           shift and go to state 44


state 27

    (12) params -> param .
    RPAREN          reduce using rule 12 (params -> param .)
    COMMA           reduce using rule 12 (params -> param .)


state 28

    (14) param -> ID .
    RPAREN          reduce using rule 14 (param -> ID .)
    COMMA           reduce using rule 14 (param -> ID .)


state 29

    (11) if_statement -> IF expr statements . ELSE statements
    (3) statements -> statements . statement
    (5) statement -> . FUNC LPAREN params RPAREN statements
    (6) statement -> . if_statement
    (7) statement -> . return_statement
    (8) statement -> . let_statement
    (11) if_statement -> . IF expr statements ELSE statements
    (10) return_statement -> . RETURN expr SEMICOLON
    (9) let_statement -> . LET ID ASSIGN expr SEMICOLON
    ELSE            shift and go to state 45
    FUNC            shift and go to state 5
    IF              shift and go to state 9
    RETURN          shift and go to state 10
    LET             shift and go to state 11

    statement                      shift and go to state 12
    if_statement                   shift and go to state 6
    return_statement               shift and go to state 7
    let_statement                  shift and go to state 8

state 30

    (22) expr -> expr NE . expr
    (15) expr -> . ID
    (16) expr -> . NUMBER
    (17) expr -> . FALSE
    (18) expr -> . TRUE
    (19) expr -> . NOT expr
    (20) expr -> . MINUS expr
    (21) expr -> . LPAREN expr RPAREN
    (22) expr -> . expr NE expr
    (23) expr -> . expr EQ expr
    (24) expr -> . expr GT expr
    (25) expr -> . expr LT expr
    (26) expr -> . expr DIVIDE expr
    (27) expr -> . expr TIMES expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr PLUS expr
    ID              shift and go to state 16
    NUMBER          shift and go to state 17
    FALSE           shift and go to state 18
    TRUE            shift and go to state 19
    NOT             shift and go to state 20
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 22

    expr                           shift and go to state 46

state 31

    (23) expr -> expr EQ . expr
    (15) expr -> . ID
    (16) expr -> . NUMBER
    (17) expr -> . FALSE
    (18) expr -> . TRUE
    (19) expr -> . NOT expr
    (20) expr -> . MINUS expr
    (21) expr -> . LPAREN expr RPAREN
    (22) expr -> . expr NE expr
    (23) expr -> . expr EQ expr
    (24) expr -> . expr GT expr
    (25) expr -> . expr LT expr
    (26) expr -> . expr DIVIDE expr
    (27) expr -> . expr TIMES expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr PLUS expr
    ID              shift and go to state 16
    NUMBER          shift and go to state 17
    FALSE           shift and go to state 18
    TRUE            shift and go to state 19
    NOT             shift and go to state 20
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 22

    expr                           shift and go to state 47

state 32

    (24) expr -> expr GT . expr
    (15) expr -> . ID
    (16) expr -> . NUMBER
    (17) expr -> . FALSE
    (18) expr -> . TRUE
    (19) expr -> . NOT expr
    (20) expr -> . MINUS expr
    (21) expr -> . LPAREN expr RPAREN
    (22) expr -> . expr NE expr
    (23) expr -> . expr EQ expr
    (24) expr -> . expr GT expr
    (25) expr -> . expr LT expr
    (26) expr -> . expr DIVIDE expr
    (27) expr -> . expr TIMES expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr PLUS expr
    ID              shift and go to state 16
    NUMBER          shift and go to state 17
    FALSE           shift and go to state 18
    TRUE            shift and go to state 19
    NOT             shift and go to state 20
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 22

    expr                           shift and go to state 48

state 33

    (25) expr -> expr LT . expr
    (15) expr -> . ID
    (16) expr -> . NUMBER
    (17) expr -> . FALSE
    (18) expr -> . TRUE
    (19) expr -> . NOT expr
    (20) expr -> . MINUS expr
    (21) expr -> . LPAREN expr RPAREN
    (22) expr -> . expr NE expr
    (23) expr -> . expr EQ expr
    (24) expr -> . expr GT expr
    (25) expr -> . expr LT expr
    (26) expr -> . expr DIVIDE expr
    (27) expr -> . expr TIMES expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr PLUS expr
    ID              shift and go to state 16
    NUMBER          shift and go to state 17
    FALSE           shift and go to state 18
    TRUE            shift and go to state 19
    NOT             shift and go to state 20
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 22

    expr                           shift and go to state 49

state 34

    (26) expr -> expr DIVIDE . expr
    (15) expr -> . ID
    (16) expr -> . NUMBER
    (17) expr -> . FALSE
    (18) expr -> . TRUE
    (19) expr -> . NOT expr
    (20) expr -> . MINUS expr
    (21) expr -> . LPAREN expr RPAREN
    (22) expr -> . expr NE expr
    (23) expr -> . expr EQ expr
    (24) expr -> . expr GT expr
    (25) expr -> . expr LT expr
    (26) expr -> . expr DIVIDE expr
    (27) expr -> . expr TIMES expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr PLUS expr
    ID              shift and go to state 16
    NUMBER          shift and go to state 17
    FALSE           shift and go to state 18
    TRUE            shift and go to state 19
    NOT             shift and go to state 20
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 22

    expr                           shift and go to state 50

state 35

    (27) expr -> expr TIMES . expr
    (15) expr -> . ID
    (16) expr -> . NUMBER
    (17) expr -> . FALSE
    (18) expr -> . TRUE
    (19) expr -> . NOT expr
    (20) expr -> . MINUS expr
    (21) expr -> . LPAREN expr RPAREN
    (22) expr -> . expr NE expr
    (23) expr -> . expr EQ expr
    (24) expr -> . expr GT expr
    (25) expr -> . expr LT expr
    (26) expr -> . expr DIVIDE expr
    (27) expr -> . expr TIMES expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr PLUS expr
    ID              shift and go to state 16
    NUMBER          shift and go to state 17
    FALSE           shift and go to state 18
    TRUE            shift and go to state 19
    NOT             shift and go to state 20
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 22

    expr                           shift and go to state 51

state 36

    (28) expr -> expr MINUS . expr
    (15) expr -> . ID
    (16) expr -> . NUMBER
    (17) expr -> . FALSE
    (18) expr -> . TRUE
    (19) expr -> . NOT expr
    (20) expr -> . MINUS expr
    (21) expr -> . LPAREN expr RPAREN
    (22) expr -> . expr NE expr
    (23) expr -> . expr EQ expr
    (24) expr -> . expr GT expr
    (25) expr -> . expr LT expr
    (26) expr -> . expr DIVIDE expr
    (27) expr -> . expr TIMES expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr PLUS expr
    ID              shift and go to state 16
    NUMBER          shift and go to state 17
    FALSE           shift and go to state 18
    TRUE            shift and go to state 19
    NOT             shift and go to state 20
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 22

    expr                           shift and go to state 52

state 37

    (29) expr -> expr PLUS . expr
    (15) expr -> . ID
    (16) expr -> . NUMBER
    (17) expr -> . FALSE
    (18) expr -> . TRUE
    (19) expr -> . NOT expr
    (20) expr -> . MINUS expr
    (21) expr -> . LPAREN expr RPAREN
    (22) expr -> . expr NE expr
    (23) expr -> . expr EQ expr
    (24) expr -> . expr GT expr
    (25) expr -> . expr LT expr
    (26) expr -> . expr DIVIDE expr
    (27) expr -> . expr TIMES expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr PLUS expr
    ID              shift and go to state 16
    NUMBER          shift and go to state 17
    FALSE           shift and go to state 18
    TRUE            shift and go to state 19
    NOT             shift and go to state 20
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 22

    expr                           shift and go to state 53

state 38

    (19) expr -> NOT expr .
    (22) expr -> expr . NE expr
    (23) expr -> expr . EQ expr
    (24) expr -> expr . GT expr
    (25) expr -> expr . LT expr
    (26) expr -> expr . DIVIDE expr
    (27) expr -> expr . TIMES expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . PLUS expr
    NE              reduce using rule 19 (expr -> NOT expr .)
    EQ              reduce using rule 19 (expr -> NOT expr .)
    GT              reduce using rule 19 (expr -> NOT expr .)
    LT              reduce using rule 19 (expr -> NOT expr .)
    DIVIDE          reduce using rule 19 (expr -> NOT expr .)
    TIMES           reduce using rule 19 (expr -> NOT expr .)
    MINUS           reduce using rule 19 (expr -> NOT expr .)
    PLUS            reduce using rule 19 (expr -> NOT expr .)
    LBRACE          reduce using rule 19 (expr -> NOT expr .)
    FUNC            reduce using rule 19 (expr -> NOT expr .)
    IF              reduce using rule 19 (expr -> NOT expr .)
    RETURN          reduce using rule 19 (expr -> NOT expr .)
    LET             reduce using rule 19 (expr -> NOT expr .)
    SEMICOLON       reduce using rule 19 (expr -> NOT expr .)
    RPAREN          reduce using rule 19 (expr -> NOT expr .)


state 39

    (20) expr -> MINUS expr .
    (22) expr -> expr . NE expr
    (23) expr -> expr . EQ expr
    (24) expr -> expr . GT expr
    (25) expr -> expr . LT expr
    (26) expr -> expr . DIVIDE expr
    (27) expr -> expr . TIMES expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . PLUS expr
    NE              reduce using rule 20 (expr -> MINUS expr .)
    EQ              reduce using rule 20 (expr -> MINUS expr .)
    GT              reduce using rule 20 (expr -> MINUS expr .)
    LT              reduce using rule 20 (expr -> MINUS expr .)
    DIVIDE          reduce using rule 20 (expr -> MINUS expr .)
    TIMES           reduce using rule 20 (expr -> MINUS expr .)
    MINUS           reduce using rule 20 (expr -> MINUS expr .)
    PLUS            reduce using rule 20 (expr -> MINUS expr .)
    LBRACE          reduce using rule 20 (expr -> MINUS expr .)
    FUNC            reduce using rule 20 (expr -> MINUS expr .)
    IF              reduce using rule 20 (expr -> MINUS expr .)
    RETURN          reduce using rule 20 (expr -> MINUS expr .)
    LET             reduce using rule 20 (expr -> MINUS expr .)
    SEMICOLON       reduce using rule 20 (expr -> MINUS expr .)
    RPAREN          reduce using rule 20 (expr -> MINUS expr .)


state 40

    (21) expr -> LPAREN expr . RPAREN
    (22) expr -> expr . NE expr
    (23) expr -> expr . EQ expr
    (24) expr -> expr . GT expr
    (25) expr -> expr . LT expr
    (26) expr -> expr . DIVIDE expr
    (27) expr -> expr . TIMES expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . PLUS expr
    RPAREN          shift and go to state 54
    NE              shift and go to state 30
    EQ              shift and go to state 31
    GT              shift and go to state 32
    LT              shift and go to state 33
    DIVIDE          shift and go to state 34
    TIMES           shift and go to state 35
    MINUS           shift and go to state 36
    PLUS            shift and go to state 37


state 41

    (10) return_statement -> RETURN expr SEMICOLON .
    FUNC            reduce using rule 10 (return_statement -> RETURN expr SEMICOLON .)
    IF              reduce using rule 10 (return_statement -> RETURN expr SEMICOLON .)
    RETURN          reduce using rule 10 (return_statement -> RETURN expr SEMICOLON .)
    LET             reduce using rule 10 (return_statement -> RETURN expr SEMICOLON .)
    $end            reduce using rule 10 (return_statement -> RETURN expr SEMICOLON .)
    RBRACE          reduce using rule 10 (return_statement -> RETURN expr SEMICOLON .)
    ELSE            reduce using rule 10 (return_statement -> RETURN expr SEMICOLON .)


state 42

    (9) let_statement -> LET ID ASSIGN . expr SEMICOLON
    (15) expr -> . ID
    (16) expr -> . NUMBER
    (17) expr -> . FALSE
    (18) expr -> . TRUE
    (19) expr -> . NOT expr
    (20) expr -> . MINUS expr
    (21) expr -> . LPAREN expr RPAREN
    (22) expr -> . expr NE expr
    (23) expr -> . expr EQ expr
    (24) expr -> . expr GT expr
    (25) expr -> . expr LT expr
    (26) expr -> . expr DIVIDE expr
    (27) expr -> . expr TIMES expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr PLUS expr
    ID              shift and go to state 16
    NUMBER          shift and go to state 17
    FALSE           shift and go to state 18
    TRUE            shift and go to state 19
    NOT             shift and go to state 20
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 22

    expr                           shift and go to state 55

state 43

    (5) statement -> FUNC LPAREN params RPAREN . statements
    (1) statements -> . blk_statements
    (2) statements -> . statement
    (3) statements -> . statements statement
    (4) blk_statements -> . LBRACE statements RBRACE
    (5) statement -> . FUNC LPAREN params RPAREN statements
    (6) statement -> . if_statement
    (7) statement -> . return_statement
    (8) statement -> . let_statement
    (11) if_statement -> . IF expr statements ELSE statements
    (10) return_statement -> . RETURN expr SEMICOLON
    (9) let_statement -> . LET ID ASSIGN expr SEMICOLON
    LBRACE          shift and go to state 4
    FUNC            shift and go to state 5
    IF              shift and go to state 9
    RETURN          shift and go to state 10
    LET             shift and go to state 11

    statements                     shift and go to state 56
    blk_statements                 shift and go to state 2
    statement                      shift and go to state 3
    if_statement                   shift and go to state 6
    return_statement               shift and go to state 7
    let_statement                  shift and go to state 8

state 44

    (13) params -> params COMMA . param
    (14) param -> . ID
    ID              shift and go to state 28

    param                          shift and go to state 57

state 45

    (11) if_statement -> IF expr statements ELSE . statements
    (1) statements -> . blk_statements
    (2) statements -> . statement
    (3) statements -> . statements statement
    (4) blk_statements -> . LBRACE statements RBRACE
    (5) statement -> . FUNC LPAREN params RPAREN statements
    (6) statement -> . if_statement
    (7) statement -> . return_statement
    (8) statement -> . let_statement
    (11) if_statement -> . IF expr statements ELSE statements
    (10) return_statement -> . RETURN expr SEMICOLON
    (9) let_statement -> . LET ID ASSIGN expr SEMICOLON
    LBRACE          shift and go to state 4
    FUNC            shift and go to state 5
    IF              shift and go to state 9
    RETURN          shift and go to state 10
    LET             shift and go to state 11

    statements                     shift and go to state 58
    blk_statements                 shift and go to state 2
    statement                      shift and go to state 3
    if_statement                   shift and go to state 6
    return_statement               shift and go to state 7
    let_statement                  shift and go to state 8

state 46

    (22) expr -> expr NE expr .
    (22) expr -> expr . NE expr
    (23) expr -> expr . EQ expr
    (24) expr -> expr . GT expr
    (25) expr -> expr . LT expr
    (26) expr -> expr . DIVIDE expr
    (27) expr -> expr . TIMES expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . PLUS expr
    NE              reduce using rule 22 (expr -> expr NE expr .)
    EQ              reduce using rule 22 (expr -> expr NE expr .)
    LBRACE          reduce using rule 22 (expr -> expr NE expr .)
    FUNC            reduce using rule 22 (expr -> expr NE expr .)
    IF              reduce using rule 22 (expr -> expr NE expr .)
    RETURN          reduce using rule 22 (expr -> expr NE expr .)
    LET             reduce using rule 22 (expr -> expr NE expr .)
    SEMICOLON       reduce using rule 22 (expr -> expr NE expr .)
    RPAREN          reduce using rule 22 (expr -> expr NE expr .)
    GT              shift and go to state 32
    LT              shift and go to state 33
    DIVIDE          shift and go to state 34
    TIMES           shift and go to state 35
    MINUS           shift and go to state 36
    PLUS            shift and go to state 37


state 47

    (23) expr -> expr EQ expr .
    (22) expr -> expr . NE expr
    (23) expr -> expr . EQ expr
    (24) expr -> expr . GT expr
    (25) expr -> expr . LT expr
    (26) expr -> expr . DIVIDE expr
    (27) expr -> expr . TIMES expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . PLUS expr
    NE              reduce using rule 23 (expr -> expr EQ expr .)
    EQ              reduce using rule 23 (expr -> expr EQ expr .)
    LBRACE          reduce using rule 23 (expr -> expr EQ expr .)
    FUNC            reduce using rule 23 (expr -> expr EQ expr .)
    IF              reduce using rule 23 (expr -> expr EQ expr .)
    RETURN          reduce using rule 23 (expr -> expr EQ expr .)
    LET             reduce using rule 23 (expr -> expr EQ expr .)
    SEMICOLON       reduce using rule 23 (expr -> expr EQ expr .)
    RPAREN          reduce using rule 23 (expr -> expr EQ expr .)
    GT              shift and go to state 32
    LT              shift and go to state 33
    DIVIDE          shift and go to state 34
    TIMES           shift and go to state 35
    MINUS           shift and go to state 36
    PLUS            shift and go to state 37


state 48

    (24) expr -> expr GT expr .
    (22) expr -> expr . NE expr
    (23) expr -> expr . EQ expr
    (24) expr -> expr . GT expr
    (25) expr -> expr . LT expr
    (26) expr -> expr . DIVIDE expr
    (27) expr -> expr . TIMES expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . PLUS expr
    NE              reduce using rule 24 (expr -> expr GT expr .)
    EQ              reduce using rule 24 (expr -> expr GT expr .)
    GT              reduce using rule 24 (expr -> expr GT expr .)
    LT              reduce using rule 24 (expr -> expr GT expr .)
    LBRACE          reduce using rule 24 (expr -> expr GT expr .)
    FUNC            reduce using rule 24 (expr -> expr GT expr .)
    IF              reduce using rule 24 (expr -> expr GT expr .)
    RETURN          reduce using rule 24 (expr -> expr GT expr .)
    LET             reduce using rule 24 (expr -> expr GT expr .)
    SEMICOLON       reduce using rule 24 (expr -> expr GT expr .)
    RPAREN          reduce using rule 24 (expr -> expr GT expr .)
    DIVIDE          shift and go to state 34
    TIMES           shift and go to state 35
    MINUS           shift and go to state 36
    PLUS            shift and go to state 37


state 49

    (25) expr -> expr LT expr .
    (22) expr -> expr . NE expr
    (23) expr -> expr . EQ expr
    (24) expr -> expr . GT expr
    (25) expr -> expr . LT expr
    (26) expr -> expr . DIVIDE expr
    (27) expr -> expr . TIMES expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . PLUS expr
    NE              reduce using rule 25 (expr -> expr LT expr .)
    EQ              reduce using rule 25 (expr -> expr LT expr .)
    GT              reduce using rule 25 (expr -> expr LT expr .)
    LT              reduce using rule 25 (expr -> expr LT expr .)
    LBRACE          reduce using rule 25 (expr -> expr LT expr .)
    FUNC            reduce using rule 25 (expr -> expr LT expr .)
    IF              reduce using rule 25 (expr -> expr LT expr .)
    RETURN          reduce using rule 25 (expr -> expr LT expr .)
    LET             reduce using rule 25 (expr -> expr LT expr .)
    SEMICOLON       reduce using rule 25 (expr -> expr LT expr .)
    RPAREN          reduce using rule 25 (expr -> expr LT expr .)
    DIVIDE          shift and go to state 34
    TIMES           shift and go to state 35
    MINUS           shift and go to state 36
    PLUS            shift and go to state 37


state 50

    (26) expr -> expr DIVIDE expr .
    (22) expr -> expr . NE expr
    (23) expr -> expr . EQ expr
    (24) expr -> expr . GT expr
    (25) expr -> expr . LT expr
    (26) expr -> expr . DIVIDE expr
    (27) expr -> expr . TIMES expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . PLUS expr
    NE              reduce using rule 26 (expr -> expr DIVIDE expr .)
    EQ              reduce using rule 26 (expr -> expr DIVIDE expr .)
    GT              reduce using rule 26 (expr -> expr DIVIDE expr .)
    LT              reduce using rule 26 (expr -> expr DIVIDE expr .)
    DIVIDE          reduce using rule 26 (expr -> expr DIVIDE expr .)
    TIMES           reduce using rule 26 (expr -> expr DIVIDE expr .)
    MINUS           reduce using rule 26 (expr -> expr DIVIDE expr .)
    PLUS            reduce using rule 26 (expr -> expr DIVIDE expr .)
    LBRACE          reduce using rule 26 (expr -> expr DIVIDE expr .)
    FUNC            reduce using rule 26 (expr -> expr DIVIDE expr .)
    IF              reduce using rule 26 (expr -> expr DIVIDE expr .)
    RETURN          reduce using rule 26 (expr -> expr DIVIDE expr .)
    LET             reduce using rule 26 (expr -> expr DIVIDE expr .)
    SEMICOLON       reduce using rule 26 (expr -> expr DIVIDE expr .)
    RPAREN          reduce using rule 26 (expr -> expr DIVIDE expr .)


state 51

    (27) expr -> expr TIMES expr .
    (22) expr -> expr . NE expr
    (23) expr -> expr . EQ expr
    (24) expr -> expr . GT expr
    (25) expr -> expr . LT expr
    (26) expr -> expr . DIVIDE expr
    (27) expr -> expr . TIMES expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . PLUS expr
    NE              reduce using rule 27 (expr -> expr TIMES expr .)
    EQ              reduce using rule 27 (expr -> expr TIMES expr .)
    GT              reduce using rule 27 (expr -> expr TIMES expr .)
    LT              reduce using rule 27 (expr -> expr TIMES expr .)
    DIVIDE          reduce using rule 27 (expr -> expr TIMES expr .)
    TIMES           reduce using rule 27 (expr -> expr TIMES expr .)
    MINUS           reduce using rule 27 (expr -> expr TIMES expr .)
    PLUS            reduce using rule 27 (expr -> expr TIMES expr .)
    LBRACE          reduce using rule 27 (expr -> expr TIMES expr .)
    FUNC            reduce using rule 27 (expr -> expr TIMES expr .)
    IF              reduce using rule 27 (expr -> expr TIMES expr .)
    RETURN          reduce using rule 27 (expr -> expr TIMES expr .)
    LET             reduce using rule 27 (expr -> expr TIMES expr .)
    SEMICOLON       reduce using rule 27 (expr -> expr TIMES expr .)
    RPAREN          reduce using rule 27 (expr -> expr TIMES expr .)


state 52

    (28) expr -> expr MINUS expr .
    (22) expr -> expr . NE expr
    (23) expr -> expr . EQ expr
    (24) expr -> expr . GT expr
    (25) expr -> expr . LT expr
    (26) expr -> expr . DIVIDE expr
    (27) expr -> expr . TIMES expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . PLUS expr
    NE              reduce using rule 28 (expr -> expr MINUS expr .)
    EQ              reduce using rule 28 (expr -> expr MINUS expr .)
    GT              reduce using rule 28 (expr -> expr MINUS expr .)
    LT              reduce using rule 28 (expr -> expr MINUS expr .)
    MINUS           reduce using rule 28 (expr -> expr MINUS expr .)
    PLUS            reduce using rule 28 (expr -> expr MINUS expr .)
    LBRACE          reduce using rule 28 (expr -> expr MINUS expr .)
    FUNC            reduce using rule 28 (expr -> expr MINUS expr .)
    IF              reduce using rule 28 (expr -> expr MINUS expr .)
    RETURN          reduce using rule 28 (expr -> expr MINUS expr .)
    LET             reduce using rule 28 (expr -> expr MINUS expr .)
    SEMICOLON       reduce using rule 28 (expr -> expr MINUS expr .)
    RPAREN          reduce using rule 28 (expr -> expr MINUS expr .)
    DIVIDE          shift and go to state 34
    TIMES           shift and go to state 35


state 53

    (29) expr -> expr PLUS expr .
    (22) expr -> expr . NE expr
    (23) expr -> expr . EQ expr
    (24) expr -> expr . GT expr
    (25) expr -> expr . LT expr
    (26) expr -> expr . DIVIDE expr
    (27) expr -> expr . TIMES expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . PLUS expr
    NE              reduce using rule 29 (expr -> expr PLUS expr .)
    EQ              reduce using rule 29 (expr -> expr PLUS expr .)
    GT              reduce using rule 29 (expr -> expr PLUS expr .)
    LT              reduce using rule 29 (expr -> expr PLUS expr .)
    MINUS           reduce using rule 29 (expr -> expr PLUS expr .)
    PLUS            reduce using rule 29 (expr -> expr PLUS expr .)
    LBRACE          reduce using rule 29 (expr -> expr PLUS expr .)
    FUNC            reduce using rule 29 (expr -> expr PLUS expr .)
    IF              reduce using rule 29 (expr -> expr PLUS expr .)
    RETURN          reduce using rule 29 (expr -> expr PLUS expr .)
    LET             reduce using rule 29 (expr -> expr PLUS expr .)
    SEMICOLON       reduce using rule 29 (expr -> expr PLUS expr .)
    RPAREN          reduce using rule 29 (expr -> expr PLUS expr .)
    DIVIDE          shift and go to state 34
    TIMES           shift and go to state 35


state 54

    (21) expr -> LPAREN expr RPAREN .
    NE              reduce using rule 21 (expr -> LPAREN expr RPAREN .)
    EQ              reduce using rule 21 (expr -> LPAREN expr RPAREN .)
    GT              reduce using rule 21 (expr -> LPAREN expr RPAREN .)
    LT              reduce using rule 21 (expr -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 21 (expr -> LPAREN expr RPAREN .)
    TIMES           reduce using rule 21 (expr -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 21 (expr -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 21 (expr -> LPAREN expr RPAREN .)
    LBRACE          reduce using rule 21 (expr -> LPAREN expr RPAREN .)
    FUNC            reduce using rule 21 (expr -> LPAREN expr RPAREN .)
    IF              reduce using rule 21 (expr -> LPAREN expr RPAREN .)
    RETURN          reduce using rule 21 (expr -> LPAREN expr RPAREN .)
    LET             reduce using rule 21 (expr -> LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 21 (expr -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 21 (expr -> LPAREN expr RPAREN .)


state 55

    (9) let_statement -> LET ID ASSIGN expr . SEMICOLON
    (22) expr -> expr . NE expr
    (23) expr -> expr . EQ expr
    (24) expr -> expr . GT expr
    (25) expr -> expr . LT expr
    (26) expr -> expr . DIVIDE expr
    (27) expr -> expr . TIMES expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . PLUS expr
    SEMICOLON       shift and go to state 59
    NE              shift and go to state 30
    EQ              shift and go to state 31
    GT              shift and go to state 32
    LT              shift and go to state 33
    DIVIDE          shift and go to state 34
    TIMES           shift and go to state 35
    MINUS           shift and go to state 36
    PLUS            shift and go to state 37


state 56

    (5) statement -> FUNC LPAREN params RPAREN statements .
    (3) statements -> statements . statement
    (5) statement -> . FUNC LPAREN params RPAREN statements
    (6) statement -> . if_statement
    (7) statement -> . return_statement
    (8) statement -> . let_statement
    (11) if_statement -> . IF expr statements ELSE statements
    (10) return_statement -> . RETURN expr SEMICOLON
    (9) let_statement -> . LET ID ASSIGN expr SEMICOLON
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for LET resolved as shift
    $end            reduce using rule 5 (statement -> FUNC LPAREN params RPAREN statements .)
    RBRACE          reduce using rule 5 (statement -> FUNC LPAREN params RPAREN statements .)
    ELSE            reduce using rule 5 (statement -> FUNC LPAREN params RPAREN statements .)
    FUNC            shift and go to state 5
    IF              shift and go to state 9
    RETURN          shift and go to state 10
    LET             shift and go to state 11

    statement                      shift and go to state 12
    if_statement                   shift and go to state 6
    return_statement               shift and go to state 7
    let_statement                  shift and go to state 8

state 57

    (13) params -> params COMMA param .
    RPAREN          reduce using rule 13 (params -> params COMMA param .)
    COMMA           reduce using rule 13 (params -> params COMMA param .)


state 58

    (11) if_statement -> IF expr statements ELSE statements .
    (3) statements -> statements . statement
    (5) statement -> . FUNC LPAREN params RPAREN statements
    (6) statement -> . if_statement
    (7) statement -> . return_statement
    (8) statement -> . let_statement
    (11) if_statement -> . IF expr statements ELSE statements
    (10) return_statement -> . RETURN expr SEMICOLON
    (9) let_statement -> . LET ID ASSIGN expr SEMICOLON
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for LET resolved as shift
    $end            reduce using rule 11 (if_statement -> IF expr statements ELSE statements .)
    RBRACE          reduce using rule 11 (if_statement -> IF expr statements ELSE statements .)
    ELSE            reduce using rule 11 (if_statement -> IF expr statements ELSE statements .)
    FUNC            shift and go to state 5
    IF              shift and go to state 9
    RETURN          shift and go to state 10
    LET             shift and go to state 11

    statement                      shift and go to state 12
    if_statement                   shift and go to state 6
    return_statement               shift and go to state 7
    let_statement                  shift and go to state 8

state 59

    (9) let_statement -> LET ID ASSIGN expr SEMICOLON .
    FUNC            reduce using rule 9 (let_statement -> LET ID ASSIGN expr SEMICOLON .)
    IF              reduce using rule 9 (let_statement -> LET ID ASSIGN expr SEMICOLON .)
    RETURN          reduce using rule 9 (let_statement -> LET ID ASSIGN expr SEMICOLON .)
    LET             reduce using rule 9 (let_statement -> LET ID ASSIGN expr SEMICOLON .)
    $end            reduce using rule 9 (let_statement -> LET ID ASSIGN expr SEMICOLON .)
    RBRACE          reduce using rule 9 (let_statement -> LET ID ASSIGN expr SEMICOLON .)
    ELSE            reduce using rule 9 (let_statement -> LET ID ASSIGN expr SEMICOLON .)


Conflicts:

shift/reduce conflict for FUNC in state 56 resolved as shift
shift/reduce conflict for IF in state 56 resolved as shift
shift/reduce conflict for RETURN in state 56 resolved as shift
shift/reduce conflict for LET in state 56 resolved as shift
shift/reduce conflict for FUNC in state 58 resolved as shift
shift/reduce conflict for IF in state 58 resolved as shift
shift/reduce conflict for RETURN in state 58 resolved as shift
shift/reduce conflict for LET in state 58 resolved as shift